// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by injection-gen. DO NOT EDIT.

package client

import (
	context "context"
	json "encoding/json"
	errors "errors"
	fmt "fmt"

	v1alpha1 "github.com/google/kf/v2/pkg/apis/kf/v1alpha1"
	versioned "github.com/google/kf/v2/pkg/client/kf/clientset/versioned"
	typedkfv1alpha1 "github.com/google/kf/v2/pkg/client/kf/clientset/versioned/typed/kf/v1alpha1"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	runtime "k8s.io/apimachinery/pkg/runtime"
	schema "k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	watch "k8s.io/apimachinery/pkg/watch"
	discovery "k8s.io/client-go/discovery"
	dynamic "k8s.io/client-go/dynamic"
	rest "k8s.io/client-go/rest"
	injection "knative.dev/pkg/injection"
	dynamicclient "knative.dev/pkg/injection/clients/dynamicclient"
	logging "knative.dev/pkg/logging"
)

func init() {
	injection.Default.RegisterClient(withClientFromConfig)
	injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} {
		return Get(ctx)
	})
	injection.Dynamic.RegisterDynamicClient(withClientFromDynamic)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context {
	return context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))
}

func withClientFromDynamic(ctx context.Context) context.Context {
	return context.WithValue(ctx, Key{}, &wrapClient{dyn: dynamicclient.Get(ctx)})
}

// Get extracts the versioned.Interface client from the context.
func Get(ctx context.Context) versioned.Interface {
	untyped := ctx.Value(Key{})
	if untyped == nil {
		if injection.GetConfig(ctx) == nil {
			logging.FromContext(ctx).Panic(
				"Unable to fetch github.com/google/kf/v2/pkg/client/kf/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
		} else {
			logging.FromContext(ctx).Panic(
				"Unable to fetch github.com/google/kf/v2/pkg/client/kf/clientset/versioned.Interface from context.")
		}
	}
	return untyped.(versioned.Interface)
}

type wrapClient struct {
	dyn dynamic.Interface
}

var _ versioned.Interface = (*wrapClient)(nil)

func (w *wrapClient) Discovery() discovery.DiscoveryInterface {
	panic("Discovery called on dynamic client!")
}

func convert(from interface{}, to runtime.Object) error {
	bs, err := json.Marshal(from)
	if err != nil {
		return fmt.Errorf("Marshal() = %w", err)
	}
	if err := json.Unmarshal(bs, to); err != nil {
		return fmt.Errorf("Unmarshal() = %w", err)
	}
	return nil
}

// KfV1alpha1 retrieves the KfV1alpha1Client
func (w *wrapClient) KfV1alpha1() typedkfv1alpha1.KfV1alpha1Interface {
	return &wrapKfV1alpha1{
		dyn: w.dyn,
	}
}

type wrapKfV1alpha1 struct {
	dyn dynamic.Interface
}

func (w *wrapKfV1alpha1) RESTClient() rest.Interface {
	panic("RESTClient called on dynamic client!")
}

func (w *wrapKfV1alpha1) Apps(namespace string) typedkfv1alpha1.AppInterface {
	return &wrapKfV1alpha1AppImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "apps",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1AppImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.AppInterface = (*wrapKfV1alpha1AppImpl)(nil)

func (w *wrapKfV1alpha1AppImpl) Create(ctx context.Context, in *v1alpha1.App, opts v1.CreateOptions) (*v1alpha1.App, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "App",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.App{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1AppImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1AppImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1AppImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.App, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.App{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1AppImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.AppList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.AppList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1AppImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.App, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.App{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1AppImpl) Update(ctx context.Context, in *v1alpha1.App, opts v1.UpdateOptions) (*v1alpha1.App, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "App",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.App{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1AppImpl) UpdateStatus(ctx context.Context, in *v1alpha1.App, opts v1.UpdateOptions) (*v1alpha1.App, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "App",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.App{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1AppImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) Builds(namespace string) typedkfv1alpha1.BuildInterface {
	return &wrapKfV1alpha1BuildImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "builds",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1BuildImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.BuildInterface = (*wrapKfV1alpha1BuildImpl)(nil)

func (w *wrapKfV1alpha1BuildImpl) Create(ctx context.Context, in *v1alpha1.Build, opts v1.CreateOptions) (*v1alpha1.Build, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Build",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1BuildImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1BuildImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1BuildImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.Build, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1BuildImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.BuildList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.BuildList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1BuildImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.Build, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1BuildImpl) Update(ctx context.Context, in *v1alpha1.Build, opts v1.UpdateOptions) (*v1alpha1.Build, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Build",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1BuildImpl) UpdateStatus(ctx context.Context, in *v1alpha1.Build, opts v1.UpdateOptions) (*v1alpha1.Build, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Build",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Build{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1BuildImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) ClusterServiceBrokers() typedkfv1alpha1.ClusterServiceBrokerInterface {
	return &wrapKfV1alpha1ClusterServiceBrokerImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "clusterservicebrokers",
		}),
	}
}

type wrapKfV1alpha1ClusterServiceBrokerImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedkfv1alpha1.ClusterServiceBrokerInterface = (*wrapKfV1alpha1ClusterServiceBrokerImpl)(nil)

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) Create(ctx context.Context, in *v1alpha1.ClusterServiceBroker, opts v1.CreateOptions) (*v1alpha1.ClusterServiceBroker, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ClusterServiceBroker",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ClusterServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.ClusterServiceBroker, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ClusterServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.ClusterServiceBrokerList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ClusterServiceBrokerList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ClusterServiceBroker, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ClusterServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) Update(ctx context.Context, in *v1alpha1.ClusterServiceBroker, opts v1.UpdateOptions) (*v1alpha1.ClusterServiceBroker, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ClusterServiceBroker",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ClusterServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) UpdateStatus(ctx context.Context, in *v1alpha1.ClusterServiceBroker, opts v1.UpdateOptions) (*v1alpha1.ClusterServiceBroker, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ClusterServiceBroker",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ClusterServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ClusterServiceBrokerImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) Routes(namespace string) typedkfv1alpha1.RouteInterface {
	return &wrapKfV1alpha1RouteImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "routes",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1RouteImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.RouteInterface = (*wrapKfV1alpha1RouteImpl)(nil)

func (w *wrapKfV1alpha1RouteImpl) Create(ctx context.Context, in *v1alpha1.Route, opts v1.CreateOptions) (*v1alpha1.Route, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Route",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1RouteImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1RouteImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1RouteImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.Route, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1RouteImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.RouteList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.RouteList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1RouteImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.Route, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1RouteImpl) Update(ctx context.Context, in *v1alpha1.Route, opts v1.UpdateOptions) (*v1alpha1.Route, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Route",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1RouteImpl) UpdateStatus(ctx context.Context, in *v1alpha1.Route, opts v1.UpdateOptions) (*v1alpha1.Route, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Route",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Route{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1RouteImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) Scales(namespace string) typedkfv1alpha1.ScaleInterface {
	return &wrapKfV1alpha1ScaleImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "scales",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1ScaleImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.ScaleInterface = (*wrapKfV1alpha1ScaleImpl)(nil)

func (w *wrapKfV1alpha1ScaleImpl) Create(ctx context.Context, in *v1alpha1.Scale, opts v1.CreateOptions) (*v1alpha1.Scale, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Scale",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Scale{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ScaleImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1ScaleImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1ScaleImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.Scale, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Scale{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ScaleImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.ScaleList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ScaleList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ScaleImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.Scale, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Scale{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ScaleImpl) Update(ctx context.Context, in *v1alpha1.Scale, opts v1.UpdateOptions) (*v1alpha1.Scale, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Scale",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Scale{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ScaleImpl) UpdateStatus(ctx context.Context, in *v1alpha1.Scale, opts v1.UpdateOptions) (*v1alpha1.Scale, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Scale",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Scale{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ScaleImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) ServiceBrokers(namespace string) typedkfv1alpha1.ServiceBrokerInterface {
	return &wrapKfV1alpha1ServiceBrokerImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "servicebrokers",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1ServiceBrokerImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.ServiceBrokerInterface = (*wrapKfV1alpha1ServiceBrokerImpl)(nil)

func (w *wrapKfV1alpha1ServiceBrokerImpl) Create(ctx context.Context, in *v1alpha1.ServiceBroker, opts v1.CreateOptions) (*v1alpha1.ServiceBroker, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceBroker",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.ServiceBroker, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.ServiceBrokerList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceBrokerList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceBroker, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) Update(ctx context.Context, in *v1alpha1.ServiceBroker, opts v1.UpdateOptions) (*v1alpha1.ServiceBroker, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceBroker",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) UpdateStatus(ctx context.Context, in *v1alpha1.ServiceBroker, opts v1.UpdateOptions) (*v1alpha1.ServiceBroker, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceBroker",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceBroker{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceBrokerImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) ServiceInstances(namespace string) typedkfv1alpha1.ServiceInstanceInterface {
	return &wrapKfV1alpha1ServiceInstanceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "serviceinstances",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1ServiceInstanceImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.ServiceInstanceInterface = (*wrapKfV1alpha1ServiceInstanceImpl)(nil)

func (w *wrapKfV1alpha1ServiceInstanceImpl) Create(ctx context.Context, in *v1alpha1.ServiceInstance, opts v1.CreateOptions) (*v1alpha1.ServiceInstance, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceInstance",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstance{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.ServiceInstance, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstance{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.ServiceInstanceList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstanceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceInstance, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstance{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) Update(ctx context.Context, in *v1alpha1.ServiceInstance, opts v1.UpdateOptions) (*v1alpha1.ServiceInstance, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceInstance",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstance{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) UpdateStatus(ctx context.Context, in *v1alpha1.ServiceInstance, opts v1.UpdateOptions) (*v1alpha1.ServiceInstance, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceInstance",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstance{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) ServiceInstanceBindings(namespace string) typedkfv1alpha1.ServiceInstanceBindingInterface {
	return &wrapKfV1alpha1ServiceInstanceBindingImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "serviceinstancebindings",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1ServiceInstanceBindingImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.ServiceInstanceBindingInterface = (*wrapKfV1alpha1ServiceInstanceBindingImpl)(nil)

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) Create(ctx context.Context, in *v1alpha1.ServiceInstanceBinding, opts v1.CreateOptions) (*v1alpha1.ServiceInstanceBinding, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceInstanceBinding",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstanceBinding{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.ServiceInstanceBinding, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstanceBinding{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.ServiceInstanceBindingList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstanceBindingList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.ServiceInstanceBinding, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstanceBinding{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) Update(ctx context.Context, in *v1alpha1.ServiceInstanceBinding, opts v1.UpdateOptions) (*v1alpha1.ServiceInstanceBinding, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceInstanceBinding",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstanceBinding{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) UpdateStatus(ctx context.Context, in *v1alpha1.ServiceInstanceBinding, opts v1.UpdateOptions) (*v1alpha1.ServiceInstanceBinding, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "ServiceInstanceBinding",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.ServiceInstanceBinding{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1ServiceInstanceBindingImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) SourcePackages(namespace string) typedkfv1alpha1.SourcePackageInterface {
	return &wrapKfV1alpha1SourcePackageImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "sourcepackages",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1SourcePackageImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.SourcePackageInterface = (*wrapKfV1alpha1SourcePackageImpl)(nil)

func (w *wrapKfV1alpha1SourcePackageImpl) Create(ctx context.Context, in *v1alpha1.SourcePackage, opts v1.CreateOptions) (*v1alpha1.SourcePackage, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "SourcePackage",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.SourcePackage{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SourcePackageImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1SourcePackageImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1SourcePackageImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.SourcePackage, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.SourcePackage{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SourcePackageImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.SourcePackageList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.SourcePackageList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SourcePackageImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.SourcePackage, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.SourcePackage{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SourcePackageImpl) Update(ctx context.Context, in *v1alpha1.SourcePackage, opts v1.UpdateOptions) (*v1alpha1.SourcePackage, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "SourcePackage",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.SourcePackage{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SourcePackageImpl) UpdateStatus(ctx context.Context, in *v1alpha1.SourcePackage, opts v1.UpdateOptions) (*v1alpha1.SourcePackage, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "SourcePackage",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.SourcePackage{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SourcePackageImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) Spaces() typedkfv1alpha1.SpaceInterface {
	return &wrapKfV1alpha1SpaceImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "spaces",
		}),
	}
}

type wrapKfV1alpha1SpaceImpl struct {
	dyn dynamic.NamespaceableResourceInterface
}

var _ typedkfv1alpha1.SpaceInterface = (*wrapKfV1alpha1SpaceImpl)(nil)

func (w *wrapKfV1alpha1SpaceImpl) Create(ctx context.Context, in *v1alpha1.Space, opts v1.CreateOptions) (*v1alpha1.Space, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Space",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Space{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SpaceImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1SpaceImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1SpaceImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.Space, error) {
	uo, err := w.dyn.Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Space{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SpaceImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.SpaceList, error) {
	uo, err := w.dyn.List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.SpaceList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SpaceImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.Space, err error) {
	uo, err := w.dyn.Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Space{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SpaceImpl) Update(ctx context.Context, in *v1alpha1.Space, opts v1.UpdateOptions) (*v1alpha1.Space, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Space",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Space{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SpaceImpl) UpdateStatus(ctx context.Context, in *v1alpha1.Space, opts v1.UpdateOptions) (*v1alpha1.Space, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Space",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Space{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1SpaceImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) Tasks(namespace string) typedkfv1alpha1.TaskInterface {
	return &wrapKfV1alpha1TaskImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "tasks",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1TaskImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.TaskInterface = (*wrapKfV1alpha1TaskImpl)(nil)

func (w *wrapKfV1alpha1TaskImpl) Create(ctx context.Context, in *v1alpha1.Task, opts v1.CreateOptions) (*v1alpha1.Task, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Task",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Task{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1TaskImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1TaskImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.Task, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Task{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.TaskList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.TaskList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.Task, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Task{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskImpl) Update(ctx context.Context, in *v1alpha1.Task, opts v1.UpdateOptions) (*v1alpha1.Task, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Task",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Task{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskImpl) UpdateStatus(ctx context.Context, in *v1alpha1.Task, opts v1.UpdateOptions) (*v1alpha1.Task, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "Task",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.Task{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}

func (w *wrapKfV1alpha1) TaskSchedules(namespace string) typedkfv1alpha1.TaskScheduleInterface {
	return &wrapKfV1alpha1TaskScheduleImpl{
		dyn: w.dyn.Resource(schema.GroupVersionResource{
			Group:    "kf.dev",
			Version:  "v1alpha1",
			Resource: "taskschedules",
		}),

		namespace: namespace,
	}
}

type wrapKfV1alpha1TaskScheduleImpl struct {
	dyn dynamic.NamespaceableResourceInterface

	namespace string
}

var _ typedkfv1alpha1.TaskScheduleInterface = (*wrapKfV1alpha1TaskScheduleImpl)(nil)

func (w *wrapKfV1alpha1TaskScheduleImpl) Create(ctx context.Context, in *v1alpha1.TaskSchedule, opts v1.CreateOptions) (*v1alpha1.TaskSchedule, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "TaskSchedule",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Create(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.TaskSchedule{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskScheduleImpl) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
	return w.dyn.Namespace(w.namespace).Delete(ctx, name, opts)
}

func (w *wrapKfV1alpha1TaskScheduleImpl) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
	return w.dyn.Namespace(w.namespace).DeleteCollection(ctx, opts, listOpts)
}

func (w *wrapKfV1alpha1TaskScheduleImpl) Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha1.TaskSchedule, error) {
	uo, err := w.dyn.Namespace(w.namespace).Get(ctx, name, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.TaskSchedule{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskScheduleImpl) List(ctx context.Context, opts v1.ListOptions) (*v1alpha1.TaskScheduleList, error) {
	uo, err := w.dyn.Namespace(w.namespace).List(ctx, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.TaskScheduleList{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskScheduleImpl) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha1.TaskSchedule, err error) {
	uo, err := w.dyn.Namespace(w.namespace).Patch(ctx, name, pt, data, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.TaskSchedule{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskScheduleImpl) Update(ctx context.Context, in *v1alpha1.TaskSchedule, opts v1.UpdateOptions) (*v1alpha1.TaskSchedule, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "TaskSchedule",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).Update(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.TaskSchedule{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskScheduleImpl) UpdateStatus(ctx context.Context, in *v1alpha1.TaskSchedule, opts v1.UpdateOptions) (*v1alpha1.TaskSchedule, error) {
	in.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   "kf.dev",
		Version: "v1alpha1",
		Kind:    "TaskSchedule",
	})
	uo := &unstructured.Unstructured{}
	if err := convert(in, uo); err != nil {
		return nil, err
	}
	uo, err := w.dyn.Namespace(w.namespace).UpdateStatus(ctx, uo, opts)
	if err != nil {
		return nil, err
	}
	out := &v1alpha1.TaskSchedule{}
	if err := convert(uo, out); err != nil {
		return nil, err
	}
	return out, nil
}

func (w *wrapKfV1alpha1TaskScheduleImpl) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	return nil, errors.New("NYI: Watch")
}
