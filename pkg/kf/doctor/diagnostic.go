// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package doctor

import (
	"context"
	"fmt"
	"io"
	"os"
	"runtime"
	"strings"

	"github.com/fatih/color"
	"github.com/google/kf/v2/pkg/kf/describe"
	"github.com/google/kf/v2/pkg/kf/testutil"
)

var (
	failColor = color.New(color.FgHiRed, color.Bold)
	warnColor = color.New(color.FgHiYellow, color.Bold)
	passColor = color.New(color.FgHiGreen, color.Bold)
)

type diagnosticStatus int

const (
	// The statuses are in increasing severity.

	statusPass diagnosticStatus = iota
	statusWarn
	statusFail
)

// Assert Diagnostic can be used with our internal testing framework.
var _ testutil.Failable = (*Diagnostic)(nil)

// Diagnostic is a basic test structure that runs and reports on nested tests.
// It's modeled after the testing package.
type Diagnostic struct {
	status   diagnosticStatus
	output   []byte // Output generated by test or benchmark.
	w        io.Writer
	name     string
	children []*Diagnostic
	parent   *Diagnostic
}

// Run creates and executes a sub-test with the given name.
func (d *Diagnostic) Run(ctx context.Context, name string, f func(ctx context.Context, d *Diagnostic)) {
	child := &Diagnostic{
		w:      d.w,
		name:   d.name + "/" + name,
		parent: d,
	}
	d.children = append(d.children, child)

	// run the test in a separate goroutine so Fatal can exit out early.
	fmt.Fprintf(d.w, "=== RUN\t%s\n", child.name)

	ctx, cancel := context.WithCancel(ctx)
	go func() {
		defer cancel()

		f(ctx, child)
	}()

	<-ctx.Done()

	if child.status != statusPass {
		d.updateStatus(child.status)
		// We notify of which parent we're printing a log for because they may occur
		// out of order if a child failing causes a parent to dump their logs.
		fmt.Fprintf(d.w, "=== LOG\t%s\n", child.name)
		d.w.Write(child.output)
	}

	if d.parent == nil {
		child.Report()
	}
}

// GatedRun only executes the test function if all prior tests succeeded.
// This is useful as a way to structure top-level tests into groups with a
// logical dependence.
func (d *Diagnostic) GatedRun(ctx context.Context, name string, f func(ctx context.Context, d *Diagnostic)) {
	if d.Failed() {
		return
	}

	d.Run(ctx, name, f)
}

// Name returns the name of the Diagnostic.
func (d *Diagnostic) Name() string {
	return d.name
}

// Fatal is equivalent to Log followed by FailNow.
func (d *Diagnostic) Fatal(args ...interface{}) {
	d.Log(args...)
	d.FailNow()
}

// Fatalf is equivalent to Logf followed by FailNow.
func (d *Diagnostic) Fatalf(format string, args ...interface{}) {
	d.Logf(format, args...)
	d.FailNow()
}

// Error is equivalent to Log followed by Fail.
func (d *Diagnostic) Error(args ...interface{}) {
	d.Log(fmt.Sprintln(args...))
	d.Fail()
}

// Errorf is equivalent to Logf followed by Fail.
func (d *Diagnostic) Errorf(format string, args ...interface{}) {
	d.Log(fmt.Sprintf(format, args...))
	d.Fail()
}

// Warn logs the result then sets the status to be warn at minimum.
func (d *Diagnostic) Warn(args ...interface{}) {
	d.Log(fmt.Sprintln(args...))
	d.updateStatus(statusWarn)
}

// Warnf logs the formatted result then sets the status to be warn at minimum.
func (d *Diagnostic) Warnf(format string, args ...interface{}) {
	d.Log(fmt.Sprintf(format, args...))
	d.updateStatus(statusWarn)
}

// Helper is a no-op function to replicate the interface of testing
func (d *Diagnostic) Helper() {
	// noop
}

// FailNow marks the function as having failed and stops its execution by calling
// runtime.Goexit (which then runs all deferred calls in the current goroutine).
// Execution will continue at the parent diagnostic. If FailNow is called on
// the root Diagnostic, the goroutine is not exited.
func (d *Diagnostic) FailNow() {
	d.updateStatus(statusFail)

	if d.parent != nil {
		runtime.Goexit()
	}
}

// Fail marks the function as having failed.
func (d *Diagnostic) Fail() {
	d.updateStatus(statusFail)
}

func (d *Diagnostic) updateStatus(newStatus diagnosticStatus) {
	if newStatus > d.status {
		d.status = newStatus
	}
}

// Log formats its arguments using default formatting, analogous to Println,
// and records the text in the error log.
func (d *Diagnostic) Log(args ...interface{}) {
	d.log(fmt.Sprintln(args...))
}

// Logf formats its arguments according to the format, analogous to Printf, and
// records the text in the error log.
func (d *Diagnostic) Logf(format string, args ...interface{}) {
	d.log(fmt.Sprintf(format, args...))
}

func (d *Diagnostic) log(s string) {
	d.output = append(d.output, s...)

	if !strings.HasSuffix(s, "\n") {
		d.output = append(d.output, '\n')
	}
}

// Report creates a detailed testing style report for the execution.
func (d *Diagnostic) Report() {
	d.reportIndent(d.w)
}

func (d *Diagnostic) reportIndent(w io.Writer) {

	var prefix string
	switch d.status {
	case statusPass:
		prefix = passColor.Sprint("PASS")
	case statusWarn:
		prefix = warnColor.Sprint("WARN")
	case statusFail:
		prefix = failColor.Sprint("FAIL")
	}

	fmt.Fprintf(w, "--- %s: %s", prefix, d.name)
	fmt.Fprintln(w)

	for _, child := range d.children {
		describe.PrefixWriter(w, "    ", func(w io.Writer) {
			child.reportIndent(w)
		})
	}
}

// Failed reports whether the function has failed.
func (d *Diagnostic) Failed() bool {
	return d.status == statusFail
}

// NewDefaultDiagnostic creates a diagnostic with the root name of "doctor"
// that reports to stdout.
func NewDefaultDiagnostic() *Diagnostic {
	return NewDiagnostic("doctor", os.Stdout)
}

// NewDiagnostic creates a new diagnostic with the given name that reports to
// the given writer.
func NewDiagnostic(name string, w io.Writer) *Diagnostic {
	return &Diagnostic{name: name, w: w}
}

// Diagnosable provides a high-level way to indicate a resource can be diagnosed.
type Diagnosable interface {
	Diagnose(ctx context.Context, d *Diagnostic)
}

// DiagnosableFunc adapts a function to a Diagnosable.
type DiagnosableFunc func(ctx context.Context, d *Diagnostic)

// Diagnose implements Diagnosable.Diagnose.
func (df DiagnosableFunc) Diagnose(ctx context.Context, d *Diagnostic) {
	df(ctx, d)
}

var _ Diagnosable = (DiagnosableFunc)(nil)
